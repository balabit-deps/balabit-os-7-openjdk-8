# HG changeset patch
# User dholmes
# Date 1538206654 14400
#      Sat Sep 29 03:37:34 2018 -0400
# Node ID da06fcb193872a1df824255ec4d94e498b99a470
# Parent  0ff99c48884b366df41ce55510710e4da632582e
8205714: Initial class initialization
Reviewed-by: acorn, coleenp, kvn, vlivanov

diff -r 0ff99c48884b -r da06fcb19387 src/share/vm/oops/cpCache.cpp
--- openjdk/hotspot/src/share/vm/oops/cpCache.cpp	Mon Sep 17 15:04:58 2018 +0100
+++ openjdk/hotspot/src/share/vm/oops/cpCache.cpp	Sat Sep 29 03:37:34 2018 -0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -209,12 +209,22 @@
   if (byte_no == 1) {
     assert(invoke_code != Bytecodes::_invokevirtual &&
            invoke_code != Bytecodes::_invokeinterface, "");
+    bool do_resolve = true;
     // Don't mark invokespecial to method as resolved if sender is an interface.  The receiver
     // has to be checked that it is a subclass of the current class every time this bytecode
     // is executed.
-    if (invoke_code != Bytecodes::_invokespecial || !sender_is_interface ||
-        method->name() == vmSymbols::object_initializer_name()) {
-    set_bytecode_1(invoke_code);
+    if (invoke_code == Bytecodes::_invokespecial && sender_is_interface &&
+        method->name() != vmSymbols::object_initializer_name()) {
+      do_resolve = false;
+    }
+    // Don't mark invokestatic to method as resolved if the holder class has not yet completed
+    // initialization. An invokestatic must only proceed if the class is initialized, but if
+    // we resolve it before then that class initialization check is skipped.
+    if (invoke_code == Bytecodes::_invokestatic && !method->method_holder()->is_initialized()) {
+      do_resolve = false;
+    }
+    if (do_resolve) {
+        set_bytecode_1(invoke_code);
     }
   } else if (byte_no == 2)  {
     if (change_to_virtual) {
diff -r 0ff99c48884b -r da06fcb19387 src/share/vm/runtime/sharedRuntime.cpp
--- openjdk/hotspot/src/share/vm/runtime/sharedRuntime.cpp	Mon Sep 17 15:04:58 2018 +0100
+++ openjdk/hotspot/src/share/vm/runtime/sharedRuntime.cpp	Sat Sep 29 03:37:34 2018 -0400
@@ -1232,6 +1232,14 @@
   }
 #endif
 
+  // Do not patch call site for static call when the class is not
+  // fully initialized.
+  if (invoke_code == Bytecodes::_invokestatic &&
+      !callee_method->method_holder()->is_initialized()) {
+    assert(callee_method->method_holder()->is_linked(), "must be");
+    return callee_method;
+  }
+
   // JSR 292 key invariant:
   // If the resolved method is a MethodHandle invoke target, the call
   // site must be a MethodHandle call site, because the lambda form might tail-call
